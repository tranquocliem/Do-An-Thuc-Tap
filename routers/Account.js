const express = require("express");
const accRouter = express.Router();
const passport = require("passport");
const passportConfig = require("../configs/passport");
const JWT = require("jsonwebtoken");
const Account = require("../models/Account");
const bcrypt = require("bcrypt");
const lodash = require("lodash");
const NodeRSA = require("node-rsa");
const fs = require("fs");
const path = require("path");
const cloudinary = require("cloudinary").v2;
const SendMail = require("../configs/SendMail");

cloudinary.config({
  cloud_name: process.env.CLOUD_NAME,
  api_key: process.env.CLOUD_API_KEY,
  api_secret: process.env.CLOUD_API_SECRET,
});

// register
accRouter.post("/register", async (req, res) => {
  try {
    const {
      email,
      fullname,
      website,
      phone,
      story,
      gender,
      username,
      password,
    } = req.body;

    public_key = fs.readFileSync(
      path.resolve(__dirname, "../configs/publickey.key")
    );
    let key_public = new NodeRSA(public_key);
    let end = key_public.encrypt(password, process.env.PUBLIC_KEY);
    const passwordHash = end;

    const acc = await Account.findOne({
      $or: [{ username: username }, { email: email }],
    });

    if (acc) {
      if (acc.email === email && acc.username === username) {
        return res.status(201).json({
          message: {
            msgBody: "Username v√† Email ƒë√£ t·ªìn t·∫°i",
            msgError: true,
          },
        });
      } else if (acc.username === username) {
        return res.status(201).json({
          message: {
            msgBody: "Username ƒë√£ t·ªìn t·∫°i",
            msgError: true,
          },
        });
      } else if (acc.email === email) {
        return res.status(201).json({
          message: {
            msgBody: "Email ƒë√£ t·ªìn t·∫°i",
            msgError: true,
          },
        });
      }
    }
    const token = await JWT.sign(
      {
        email,
        fullname,
        website,
        phone,
        story,
        gender,
        username,
        passwordHash,
      },
      process.env.JWT_ACCOUNT_ACTIVATION,
      {
        expiresIn: "1d",
      }
    );

    const url = `http://localhost:3000/user/activate/${token}`;

    // await SendMail.sendMail(
    //   email,
    //   url,
    //   "K√≠ch Ho·∫°t T√†i Kho·∫£n",
    //   "Xin ch√∫c m·ª´ng! B·∫°n s·∫Øp b·∫Øt ƒë·∫ßu s·ª≠ d·ª•ng ùì≤ùì∑ùìºùìΩùì™ùì∞ùì≤ùìªùìµ.",
    //   "X√°c th·ª±c email",
    //   "24 gi·ªù"
    // );

    await SendMail.sendGrid(
      email,
      url,
      "K√≠ch Ho·∫°t T√†i Kho·∫£n",
      "Xin ch√∫c m·ª´ng! B·∫°n s·∫Øp b·∫Øt ƒë·∫ßu s·ª≠ d·ª•ng ùì≤ùì∑ùìºùìΩùì™ùì∞ùì≤ùìªùìµ.",
      "X√°c th·ª±c email",
      "24 gi·ªù"
    );

    return res.status(200).json({
      success: true,
      message: {
        msgBody: "T·∫°o t√†i kho·∫£n th√†nh c√¥ng",
        msgError: false,
      },
    });
  } catch (error) {
    return res.status(500).json({
      success: false,
      message: {
        msgBody: "C√≥ l·ªói khi ƒëƒÉng k√Ω",
        msgError: true,
      },
      error,
    });
  }
});

// x√°c th·ª±c email
accRouter.post("/activation", async (req, res) => {
  try {
    const { token } = req.body;
    const user = JWT.verify(token, process.env.JWT_ACCOUNT_ACTIVATION);
    let password = user.passwordHash;

    private_key = fs.readFileSync(
      path.resolve(__dirname, "../configs/privatekey.key")
    );
    let key_private = new NodeRSA(private_key);
    password = key_private.decrypt(password, process.env.PRIVATE_KEY);

    const variable = {
      email: user.email,
      fullname: user.fullname,
      gender: user.gender,
      username: user.username,
      password: password,
    };

    const newAcc = new Account(variable);

    await newAcc.save();

    return res.status(200).json({
      success: true,
      message: {
        msgBody: "X√°c th·ª±c t√†i kho·∫£n th√†nh c√¥ng!",
        msgError: false,
      },
    });
  } catch (error) {
    return res.status(500).json({
      success: false,
      message: {
        msgBody: "C√≥ l·ªói khi x√°c th·ª±c",
        msgError: true,
      },
      error,
    });
  }
});

//login
const signToken = (userID) => {
  return JWT.sign(
    {
      iss: "QuocLiem",
      sub: userID,
    },
    process.env.SECRET_KEY,
    { expiresIn: "1d" }
  );
};

accRouter.post(
  "/login",
  passport.authenticate("local", { session: false }),
  (req, res) => {
    if (req.isAuthenticated()) {
      const { _id, email, fullname, gender, username, status } = req.user;
      let token = signToken(_id);
      public_key = fs.readFileSync(
        path.resolve(__dirname, "../configs/publickey.key")
      );
      let key_public = new NodeRSA(public_key);
      let end = key_public.encrypt(token, process.env.PUBLIC_KEY);
      token = end;
      res.cookie("temp", token, {
        httpOnly: true,
        sameSite: true,
      });
      res.status(200).json({
        isAuthenticated: true,
        message: {
          msgBody: "ƒêƒÉng nh·∫≠p th√†nh c√¥ng",
          msgError: false,
        },
        user: { _id, email, fullname, gender, username, status },
      });
    }
  }
);

//logout
accRouter.get(
  "/logout",
  passport.authenticate("jwt", { session: false }),
  (req, res) => {
    res.clearCookie("temp");
    res.json({ user: { username: "", role: "" }, success: true });
  }
);

//Get th√¥ng tin User
accRouter.get(
  "/getUser",
  passport.authenticate("jwt", { session: false }),
  async (req, res) => {
    try {
      const user = await Account.findOne({
        username: req.query.username,
      }).select("-password -resetLink -public_id");

      if (user) {
        return res.status(200).json({ user });
      } else {
        return res.status(203).json({
          message: {
            msgBody: "Kh√¥ng c√≥ ng∆∞·ªùi n√†y",
            msgError: true,
          },
          error,
        });
      }
    } catch (error) {
      return res.status(500).json({
        message: {
          msgBody: "L·ªói!!!",
          msgError: true,
        },
        error,
      });
    }
  }
);

//Update th√¥ng tin user
accRouter.patch(
  "/updateUser",
  passport.authenticate("jwt", { session: false }),
  async (req, res) => {
    try {
      const { avatar, fullname, phone, story, website, gender, public_id } =
        req.body;
      if (!fullname) {
        return res
          .status(400)
          .json({ message: { msgBody: "Kh√¥ng ƒë·ªÉ tr·ªëng h·ªç v√† t√™n" } });
      }

      if (public_id === 0) {
        await Account.findOneAndUpdate(
          { _id: req.user._id },
          { avatar, fullname, phone, story, website, gender }
        );
      } else {
        await Account.findOneAndUpdate(
          { _id: req.user._id },
          { avatar, fullname, phone, story, website, gender, public_id }
        );
      }

      res.status(200).json({
        message: {
          msgBody: "C·∫≠p nh·∫≠t th√¥ng tin th√†nh c√¥ng",
          msgError: false,
        },
      });
    } catch (error) {
      return res.status(500).json({
        message: {
          msgBody: "C·∫≠p nh·∫≠t kh√¥ng th√†nh c√¥ng",
          msgError: true,
        },
        error,
      });
    }
  }
);

//Xo√° ·∫£nh cloudinary
accRouter.get(
  "/destroyAvatar",
  passport.authenticate("jwt", { session: false }),
  async (req, res) => {
    try {
      const { public_id } = req.user;
      if (!public_id) {
        return res.status(203).json({
          success: false,
          message: {
            msgBody: "H√¨nh ·∫£nh kh√¥ng t·ªìn t·∫°i",
            msgError: true,
          },
        });
      }
      cloudinary.uploader.destroy(public_id, async (err, result) => {
        if (err) throw err;

        res.status(200).json({
          success: true,
          message: {
            msgBody: "Xo√° th√†nh c√¥ng",
            msgError: false,
          },
        });
      });
    } catch (error) {
      return res.status(500).json({
        success: false,
        message: {
          msgBody: "L·ªói!!!",
          msgError: true,
        },
        error,
      });
    }
  }
);

// G·ª£i √Ω
accRouter.get(
  "/suggestions",
  passport.authenticate("jwt", { session: false }),
  async (req, res) => {
    try {
      const newArr = [...req.user.following, req.user._id];

      const num = req.query.num || 5;

      const users = await Account.aggregate([
        { $match: { _id: { $nin: newArr } } },
        { $sample: { size: num } },
        // {
        //   $lookup: {
        //     from: "Account",
        //     localField: "followers",
        //     foreignField: "_id",
        //     as: "followers",
        //   },
        // },
        // {
        //   $lookup: {
        //     from: "Account",
        //     localField: "following",
        //     foreignField: "_id",
        //     as: "following",
        //   },
        // },
      ]).project("-password");

      return res.status(200).json({
        success: true,
        message: {
          msgBody: "L·∫•y g·ª£i √Ω th√†nh c√¥ng",
          msgError: false,
        },
        total: users.length,
        users,
      });
    } catch (error) {
      return res.status(500).json({
        success: false,
        message: {
          msgBody: "L·ªói!!!",
          msgError: true,
        },
      });
    }
  }
);

//g·ª≠i link qua mail ƒë·ªÉ ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u ƒë√£ qu√™n
accRouter.post("/forgetPass", async (req, res) => {
  const { email } = req.body;

  if (!email) {
    return res.status(400).json({
      success: false,
      message: {
        msgBody: "Vui l√≤ng nh·∫≠p E-mail",
        msgError: true,
      },
    });
  } else {
    try {
      const user = await Account.findOne({ email });

      if (!user) {
        return res.status(203).json({
          success: false,
          message: {
            msgBody: "E-mail kh√¥ng t·ªìn t·∫°i",
            msgError: true,
          },
        });
      } else {
        const valiToken = user.resetLink;

        JWT.verify(valiToken, process.env.JWT_RESET_PASSWORD, async (err) => {
          if (err) {
            if ((err.name && err.name === "TokenExpiredError") || !valiToken) {
              const token = await JWT.sign(
                { _id: user._id },
                process.env.JWT_RESET_PASSWORD,
                { expiresIn: "10m" }
              );

              const url = `http://localhost:3000/resetPassword/${token}`;

              await user.updateOne({ resetLink: token });

              await SendMail.sendGrid(
                email,
                url,
                "ƒê·∫∑t L·∫°i M·∫≠t Kh·∫©u",
                "B·∫°n ƒë√£ qu√™n m·∫≠t kh·∫©u khi s·ª≠ d·ª•ng ùì≤ùì∑ùìºùìΩùì™ùì∞ùì≤ùìªùìµ.",
                "ƒê·∫∑t l·∫°i m·∫≠t kh·∫©u",
                "10 ph√∫t"
              );

              return res.status(200).json({
                success: true,
                message: {
                  msgBody: "Th√†nh c√¥ng",
                  msgError: false,
                },
              });
            } else {
              res.status(203).json({
                success: false,
                message: {
                  msgBody: "C√≥ l·ªói khi x·ª≠ l√Ω",
                  msgError: true,
                },
              });
            }
          } else if (!err || valiToken) {
            return res.status(201).json({
              success: false,
              message: {
                msgBody:
                  "E-mail n√†y ƒë√£ ƒë∆∞·ª£c g·ª≠i r·ªìi. N·∫øu c√≥ v·∫ßn ƒë·ªÅ c√≥ th·ªÉ g·ª≠i l·∫°i sau 10 ph√∫t",
                msgError: true,
              },
            });
          }
        });
      }
    } catch (error) {
      return res.status(500).json({
        success: false,
        message: {
          msgBody: "C√≥ l·ªói x√£y ra",
          msgError: true,
        },
        error,
      });
    }
  }
});

//reset l·∫°i m·∫≠t kh·∫©u ƒë√£ qu√™n
accRouter.post("/resetPass", (req, res) => {
  const { resetLink, newPassword } = req.body;

  if (newPassword && resetLink) {
    JWT.verify(resetLink, process.env.JWT_RESET_PASSWORD, (err) => {
      if (err) {
        res.status(400).json({
          success: false,
          message: {
            msgBody: "C√≥ l·ªói v·ªõi m√£ ho·∫∑c kh√¥ng c√≤n hi·ªáu l·ª±c",
            msgError: true,
          },
          err,
        });
        return;
      } else {
        Account.findOne({ resetLink }, (err, user) => {
          if (err) {
            res.status(400).json({
              success: false,
              message: {
                msgBody: "C√≥ l·ªói khi t√¨m ki·∫øm t√†i kho·∫£n n√†y",
                msgError: true,
              },
            });
            return;
          } else if (!user) {
            res.status(201).json({
              success: false,
              message: {
                msgBody: "ƒê∆∞·ªùng link kh√¥ng c√≤n t·ªìn t·∫°i",
                msgError: true,
              },
            });
            return;
          } else {
            const updatePassword = {
              password: newPassword,
              resetLink: "",
            };
            // h√†m extend() gi√∫p overwrite l·∫°i user
            // vd: user = {_id:"1",username:"liem",password:"123456",resetLink:"gheyf"}
            // extend({_id:"1",username:"liem",password:"123456",resetLink:"gheyf"},{password: 1234567,resetLink: "",})
            // => user = {_id:"1",username:"liem",password:"1234567",resetLink:""}
            user = lodash.extend(user, updatePassword);
            //h√†m save n·∫øu _id ƒë√£ t·ªìn t·∫°i s·∫Ω update ng∆∞·ª£c l·∫°i th√¨ s·∫Ω l√† insert
            user.save((err) => {
              if (err) {
                res.status(400).json({
                  success: false,
                  message: {
                    msgBody: "ƒê·∫∑t l·∫°i m·∫≠t kh·∫©u kh√¥ng th√†nh c√¥ng",
                    msgError: true,
                  },
                  err,
                });
                return;
              } else {
                return res.status(200).json({
                  success: true,
                  message: {
                    msgBody: "ƒê√£ ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u th√†nh c√¥ng!",
                    msgError: false,
                  },
                });
              }
            });
          }
        });
      }
    });
  } else {
    res.status(400).json({
      success: false,
      message: {
        msgBody: "L·ªói!!! kh√¥ng ƒë·ªß th√¥ng tin",
        msgError: true,
      },
    });
    return;
  }
});

//ki·ªÉm tra m√£ token
accRouter.post("/examJWT", (req, res) => {
  const { token } = req.body;

  //token h·∫øt h·∫°n
  //eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiI1ZmYxNDgyYTZlYzAzZjM0ZWM1YjUwNmEiLCJpYXQiOjE2MDk3MjYzMjMsImV4cCI6MTYwOTcyNjkyM30.Qmnrq9UFggNM4l8DO-I-kOa3UKeiS1YXmi8Bp2Fbqtw

  JWT.verify(token, process.env.JWT_RESET_PASSWORD, (err, decoded) => {
    if (err) {
      if ((err.name && err.name === "TokenExpiredError") || !token) {
        res.status(400).json({
          message: {
            msgBody: "H·∫øt h·∫°n",
            msgError: true,
          },
          err,
        });
        return;
      } else {
        res.status(400).json({
          message: {
            msgBody: "C√≥ l·ªói",
            msgError: true,
          },
          err,
        });
        return;
      }
    } else {
      res.status(200).json({
        message: {
          msgBody: "Ok!!!",
          msgError: false,
        },
        decoded,
      });
    }
  });
});

//ƒë·ªïi m·∫≠t kh·∫©u t√†i kho·∫£n
accRouter.post(
  "/changePass",
  passport.authenticate("jwt", { session: false }),
  (req, res) => {
    const { old_Password, password, configPassword } = req.body;
    const { username, email } = req.user;
    Account.findOne(
      { $or: [{ username: username }, { email: email }] },
      (err, user) => {
        if (err || !user) {
          return res.status(500).json({
            message: {
              msgBody: "L·ªói ho·∫∑c t√†i kho·∫£n kh√¥ng t·ªìn t·∫°i",
              msgError: true,
            },
            err,
          });
        }
        if (password !== configPassword) {
          return res.status(203).json({
            message: {
              msgBody: "M·∫≠t kh·∫©u x√°c nh·∫≠n kh√¥ng ƒë√∫ng",
              msgError: true,
            },
          });
        }
        //c·∫ßn nh·∫≠p pass c·ªß v√† so s√°nh v·ªõi pass v·ªõi csdl
        // bcrypt.compare(
        //   old_Password,
        //   req.user.password,
        //   function (err, isMatch) {
        //     console.log(err);
        //   }
        // );
        bcrypt.compare(
          old_Password,
          req.user.password,
          function (err, isMatch) {
            if (err) {
              res.status(400).json({
                message: {
                  msgBody: "C√≥ L·ªói!!!",
                  msgError: true,
                },
                err,
              });
            }
            if (!isMatch) {
              res.status(203).json({
                isMatch: isMatch,
                message: {
                  msgBody: "M·∫≠t kh·∫©u c≈© kh√¥ng ƒë√∫ng",
                  msgError: true,
                },
              });
            } else {
              const updatePassword = {
                password: password,
              };
              user = lodash.extend(user, updatePassword);
              user.save((err, result) => {
                if (err) {
                  return res.status(500).json({
                    message: {
                      msgBody: "L·ªói th√™m kh√¥ng th√†nh c√¥ng",
                      msgError: true,
                    },
                    err,
                  });
                }
                res.status(200).json({
                  message: {
                    msgBody: "Thay ƒê·ªïi M·∫≠t Kh·∫©u Th√†nh C√¥ng",
                    msgError: false,
                  },
                });
              });
            }
          }
        );
      }
    );
  }
);

//search user
accRouter.get(
  "/searchUser",
  passport.authenticate("jwt", { session: false }),
  async (req, res) => {
    try {
      const users = await Account.find({
        username: { $regex: req.query.username },
      })
        .limit(10)
        .select("fullname username avatar");
      res.status(200).json({ users });
    } catch (error) {
      return res.status(500).json({
        message: {
          msgBody: "L·ªói!!!",
          msgError: true,
        },
        error,
      });
    }
  }
);

//t√†i kho·∫£n ƒëang hi·ªán h√†nh
accRouter.get(
  "/authenticated",
  passport.authenticate("jwt", { session: false }),
  (req, res) => {
    const {
      _id,
      fullname,
      email,
      username,
      gender,
      avatar,
      phone,
      website,
      story,
      following,
      followers,
      status,
    } = req.user;
    res.status(200).json({
      isAuthenticated: true,
      user: {
        _id,
        fullname,
        email,
        username,
        gender,
        avatar,
        phone,
        website,
        story,
        following,
        followers,
        status,
      },
    });
  }
);

module.exports = accRouter;
